**概述**

- 优势
  - 并行和并发
    - 并行：多个G1的回收线程都同时工作，有效利用多核计算能力。此时用户线程STW。
    - 并发：G1的回收线程可以被中断，然后唤醒后重新继续标记。此时不会让用户线程STW。
  - 分代收集
    - 将区域会划分成新生代和老年代等
    - 会把内存区域划分成多个region，每个region会从逻辑上区分新生代和老年代。**而且每个region的大小是一样的**
    - 和之前GC算法不同，他能同时回收新生代和老年代
  - 空间整合
    - CMS:"标记-清除"算法，内存碎片、若干次GC后进行一次碎片整理。
    - G1将内存划分一个个region。内存的回收以region作为单位，并且之间是使用复制算法。但是整体上看是”标记-整理“算法，因为region的分配也是连续的。这样的话，即使长时间运行，空间也是有序的，不会因为没有连续空间而导致内存不足。**尤其是当堆很大的时候，效果更好。**
  - 可预测的时间模型 (soft real time)
    - 可以明确指定在M时间内，花在GC线程的时间不会超过N。
    - 由于分区的原因，可以选择只回收单个或者某几个region，更加可以控制时间。
    - 追踪各个Region中的垃圾价值大小（回收的时间经验值和回收的空间）。在后台维护一个优先列表，每次跟进允许的手机时间，优先回收价值最高的region。
    - 相比CMS，可能很难做到最好情况下的停顿，但是最差情况要好的多。
- 劣势
  - 对于CMS，没有压倒性的优势。
  - GC需要的内存占用和执行需要的负载都要比CMS高。
  - 在大内存情况下G1比CMS更优，平衡点在6~8G左右。

- 重要参数
  - -XX:+UseG1GC
  - -XX:G1HeapRegionSize。设置每个region的大小。默认是堆大小的1/2000，会划分出2048个区域 。1M~32M之间            //TODO
  - -XX:MaxGCPauseMillis：90%可以空置在这个停顿时间内，默认200ms。
  - -XX:ParallelGCThread。设置STW过程中的回收线程数，默认8个。
  - -XX:ConcGCThreads。设置并发标记的线程数，一般是1/4*ParallelGCThread
  - -XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用比例阈值。默认45%
- G1的参数优化逻辑
  - 打开G1回收期
  - 设置最大堆大小
  - 设置最大停顿时间
- 三种GC回收模式
  - YoungGC
  - MixedGC
  - FullGC
- 什么时候G1应该替换CMS
  - 超过50%的Java堆被活跃对象使用
  - 对象分配频率或老年代提升频率变化很大
  - GC停顿时间超过0.5s

- region的定义
  - 每个region都是一样大小的
  - 分为4类
    - Old/Eden/Survivor/Humongous
- G1回收器的过程
  - 年轻代GC（YoungGC）
    - Eden区满了之后，开始YGC。
    - YGC是一个并行的独占式回收器
    - 在YGC阶段，会STW，启动多线程开始年轻代的回收。
    - 然后把Eden区的对象copy进入Survivor区或者老年代，或者都有
  - 老年代并发标记过程（Concurrent Marking）
    - 内存使用达到配置的阈值（默认45%），开始老年代的并发标记过程。
  - 混合回收（Mixed GC）
    - 标记完老年代后，开始混合回收。
    - GC把老年代的存活对象放入空闲区域，这些空闲区域就变成了老年代。
    - G1的老年代回收只需要扫描回收一部分Region就可以了。
    - 同时，老年代和年轻代是一起回收的
  - 如果需要，单线程，独占式，高轻度的fullgc是存在的。类似CMS一样，失败后的兜底方案。
  - ![image-20210424120105554](/Users/height/Library/Application Support/typora-user-images/image-20210424120105554.png)



- RememberedSet (https://www.bilibili.com/video/BV1PJ411n7xZ?p=193&spm_id_from=pageDriver)
  - 解决的问题：在做YGC时，回收年轻代，需要判断是否被引用，需要对整个堆进行扫描，效率非常低。
  - 解决方案
    - 每个region都会配置一个RSet
    - 每次对象有新引用时，会通过一个写屏障来中断这个操作
    - 检查写入的引用是否和被引用对象在同一个region，如果不在同一个region，就会在被引用对象的RSet中添加一个引用的region。这个过程中使用CardTable。
    - 更新RSet的时候，因为需要**同步**，所以在引用发生的时候，先异步加入dirty_card_queue，然后再同步至RSet。

![image-20210424213903537](/Users/height/Library/Application Support/typora-user-images/image-20210424213903537.png)



- YGC流程
  - 扫描根
  - 更新RSet
  - 处理RSet
  - 复制对象
  - 处理引用
- 并发标记过程 TODO
  - 初始标记阶段**STW**:标记从根节点直接可达的对象
  - 跟区域扫描

https://blog.csdn.net/jiankunking/article/details/85626279


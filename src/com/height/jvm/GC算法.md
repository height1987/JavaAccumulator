#### 概念

什么是垃圾？**没有任何指针指向的对象**



#### GC算法介绍

* 优点
    * 内存的自动管理能让使用者更加方便，focus在业务
* 缺点
    * 对于开发者是黑盒子，如果出现问题，造成开发者可能不能很好定位问题



#### GC算法

* 什么是垃圾？ **标记阶段**

    * 引用计数算法
        * 优点：1.清理效率高，只要无引用就立即清理，2.可以不用STW
        * 缺点：1.需要开辟额外的空间存储计数。2每次引用需要更新计数。3.无法解决循环引用问题
    * 可达性分析算法
        * 方法
            * 通过GC ROOT寻找有用的对象
                * 栈帧本地变量表中的局部变量、临时变量（虚拟机栈）
                * JNI本地方法栈中引用的对象（本地方法栈）
                * 方法区中类里的静态变量（方法区）
                * 方法区的常量引用对象，如StringTable中引用的值（方法区）
                * 被synchronized锁持有的对象（方法区）
                * 运行时常量池中持有的对象，如class对象和npe对象 （运行时常量池）
                * 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
        * 优缺点
            * 必须STW，无需额外存储空间，执行效率可能随对象增加而下降
        * STW
        * OOPMap
        * SafePoint

* 如何清除垃圾？**清理阶段**

    * 标记-清除算法
        * 方案：先标记，再清除。清除的时候 是把可以清除的区块放到你的**空闲列表**，后面需要的时候就直接覆盖了。
        * 优缺点
            * 优：逻辑比较简单
            * 缺：执行效率不稳定。随着对象数量增加而效率下降，要经过2次O(n)遍历。
            * 缺：内存空间碎片化。因为清除时比较随机，导致内存碎片增加，等到大对象时，可能空间不满而需要GC。
            * 三色算法:另外文章解释
    * 复制算法
        * 方案：每次内存只使用一半，使用完，就把存活的copy到另一半，然后把另一半清除掉。
        * 适合场景：非常适合新生代的场景，**存活少，空间少**。S0/S1小，所以内存浪费不高，而且能存活下来的非常少。
        * 优缺点
            * 优：没有内存碎片问题，分配的时候可以直接使用**指针碰撞**的方式进行处理
            * 缺：每次使用一半内存，效率不高
            * 缺：如果大量对象存活，copy的量较大，效率较低,需要STW
    * 标记-整理算法
        * 方案：标记逻辑和标记清除算法一致。但他是标记后，把不用的对象向内存空间的一端移动，最后清除某个边界外的所有内存。
        * 适合场景：
        * 优缺点
            * 优：解决内存碎片问题
            * 缺：效率低于复制算法
            * 缺：移动对象，并且修改引用地址，是很繁重的工作
            * 需要STW
    * 三种算法的比较

| 收集器   | 标记-清除          | 标记-整理  | 复制算法              |
| :------- | ------------------ | ---------- | --------------------- |
| 速度     | 中等               | 最慢       | 最快                  |
| 空间开销 | 少(但是会堆积碎片) | 少(无碎片) | 需要2倍的空间(无碎片) |
| 移动对象 | 否                 | 是         | 是                    |

总结：效率上 复制算法最高，但是空间要求太高。



* 常用的垃圾回收

  ![image-20210420234319274](https://outter.oss-cn-shanghai.aliyuncs.com/gcCategory.png)

* 垃圾回收具体算法

| 收集器                     | 类型      | 作用 | 使用算法      | 特点         |                         |
| :------------------------- | --------- | ---- | ------------- | ------------ | ----------------------- |
| Serial                     | 串行      | 新   | 复制算法      | 响应速度优先 | -XX:UseSerialGC         |
| Serial Old                 | 串行      | 老   | 标记-压缩     | 响应速度优先 | -XX:UseSerialGC         |
| ParNew                     | 并行      | 新   | 复制          | 响应速度优先 | -XX:+UseParNewGC        |
| Parallel Scavenge          | 并行      | 新   | 复制          | 吞吐量优先   | -XX:+UseParallelGC      |
| Parallel Old               | 并行      | 老   | 标记-压缩     | 吞吐量优先   | -XX:+UseParallelOldGC   |
| CMS(Concurrent Mark-Sweep) | 并行      | 老   | 标记-清除     | 响应速度优先 | -XX:+UseConcMarkSweepGC |
| G1(Garbage-First)          | 并行/并发 | 新老 | 复制&标记压缩 | 响应速度优先 | -XX:+UseG1GC            |

*响应时间：保证GC 暂停用户代码的时间*

*吞吐量：用户代码执行时间  /（用户代码执行时间+GC执行时间）*



- 对象分配与GC触发

![image-20210421093118886](https://outter.oss-cn-shanghai.aliyuncs.com/gcFlow.png)






- GC Log分析

    1)YGC
![image-20210421110510471](https://outter.oss-cn-shanghai.aliyuncs.com/ygc_log1.png)
    2)FGC
![image-20210421111006106](https://outter.oss-cn-shanghai.aliyuncs.com/fgc_log.png)



- 强软弱虚引用
  - 强：默认的都是强引用，new等，只要被引用的，即使被oom也不能被回收的引用
  - 软：当内存不够时，快oom了，则会进行回收
  - 弱：只要发生GC，就会被回收
  - 虚：回收时收到通知，不能通过虚引用获得对象
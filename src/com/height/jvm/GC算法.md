####  概念

什么是垃圾？**没有任何指针指向的对象**

#### GC算法介绍

* 优点
    * 内存的自动管理能让使用者更加方便，focus在业务
* 缺点
    * 对于开发者是黑盒子，如果出现问题，造成开发者可能不能很好定位问题

#### GC算法

* 什么是垃圾？ **标记阶段**

    * 引用计数算法
        * 优点：1.清理效率高，只要无引用就立即清理，2.可以不用STW
        * 缺点：1.需要开辟额外的空间存储计数。2每次引用需要更新计数。3.无法解决循环引用问题
    * 可达性分析算法
        * 方法
            * 通过GC ROOT寻找有用的对象
                * 栈帧本地变量表中的局部变量、临时变量（虚拟机栈）
                * JNI本地方法栈中引用的对象（本地方法栈）
                * 方法区中类里的静态变量（方法区）
                * 方法区的常量引用对象，如StringTable中引用的值（方法区）
                * 被synchronized锁持有的对象（方法区）
                * 运行时常量池中持有的对象，如class对象和npe对象 （运行时常量池）
                * 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
        * 优缺点
            * 必须STW，无需额外存储空间，执行效率可能随对象增加而下降
        * STW
        * OOPMap
        * SafePoint

* 如何清除垃圾？**清理阶段**

    * 标记-清除算法
        * 方案：先标记，再清除。清除的时候 是把可以清除的区块放到你的**空闲列表**，后面需要的时候就直接覆盖了。
        * 优缺点
            * 优：逻辑比较简单
            * 缺：执行效率不稳定。随着对象数量增加而效率下降，要经过2次O(n)遍历。
            * 缺：内存空间碎片化。因为清除时比较随机，导致内存碎片增加，等到大对象时，可能空间不满而需要GC。
            * 三色算法:另外文章解释
    * 复制算法
        * 方案：每次内存只使用一半，使用完，就把存活的copy到另一半，然后把另一半清除掉。
        * 适合场景：非常适合新生代的场景，**存活少，空间少**。S0/S1小，所以内存浪费不高，而且能存活下来的非常少。
        * 优缺点
            * 优：没有内存碎片问题，分配的时候可以直接使用**指针碰撞**的方式进行处理
            * 缺：每次使用一半内存，效率不高
            * 缺：如果大量对象存活，copy的量较大，效率较低,需要STW
    * 标记-整理算法
        * 方案：标记逻辑和标记清除算法一致。但他是标记后，把不用的对象向内存空间的一端移动，最后清除某个边界外的所有内存。
        * 适合场景：
        * 优缺点
            * 优：解决内存碎片问题
            * 缺：效率低于复制算法
            * 缺：移动对象，并且修改引用地址，是很繁重的工作
            * 需要STW
    * 三种算法的比较

| 收集器   | 标记-清除          | 标记-整理  | 复制算法              |
| :------- | ------------------ | ---------- | --------------------- |
| 速度     | 中等               | 最慢       | 最快                  |
| 空间开销 | 少(但是会堆积碎片) | 少(无碎片) | 需要2倍的空间(无碎片) |
| 移动对象 | 否                 | 是         | 是                    |

总结：效率上 复制算法最高，但是空间要求太高。



* 常用的垃圾回收

  ![image-20210420234319274](https://outter.oss-cn-shanghai.aliyuncs.com/gcCategory.png)

* 注意

  - Parallel Scavenge和CMS使用的框架不同，所以没有匹配
  - ParNew GC +CMS GC +Serial Old GC 。因为CMS是并发的场景，有可能回收失败，到时Serial OldGC作为一个后备方案。

* 垃圾回收具体算法

| 收集器                     | 类型      | 作用 | 使用算法      | 特点         |                         |
| :------------------------- | --------- | ---- | ------------- | ------------ | ----------------------- |
| Serial                     | 串行      | 新   | 复制算法      | 响应速度优先 | -XX:UseSerialGC         |
| Serial Old                 | 串行      | 老   | 标记-压缩     | 响应速度优先 | -XX:UseSerialGC         |
| ParNew                     | 并行      | 新   | 复制          | 响应速度优先 | -XX:+UseParNewGC        |
| Parallel Scavenge          | 并行      | 新   | 复制          | 吞吐量优先   | -XX:+UseParallelGC      |
| Parallel Old               | 并行      | 老   | 标记-压缩     | 吞吐量优先   | -XX:+UseParallelOldGC   |
| CMS(Concurrent Mark-Sweep) | 并行      | 老   | 标记-清除     | 响应速度优先 | -XX:+UseConcMarkSweepGC |
| G1(Garbage-First)          | 并行/并发 | 新老 | 复制&标记压缩 | 响应速度优先 | -XX:+UseG1GC            |

*响应时间：保证GC 暂停用户代码的时间*

*吞吐量：用户代码执行时间  /（用户代码执行时间+GC执行时间）*

- - 

- 对象分配与GC触发

![image-20210421093118886](https://outter.oss-cn-shanghai.aliyuncs.com/gcFlow.png)






- GC Log分析

    1)YGC
![image-20210421110510471](https://outter.oss-cn-shanghai.aliyuncs.com/ygc_log1.png)
    2)FGC
![image-20210421111006106](https://outter.oss-cn-shanghai.aliyuncs.com/fgc_log.png)



- 强软弱虚引用
  - 强：默认的都是强引用，new等，只要被引用的，即使被oom也不能被回收的引用
  - 软：当内存不够时，快oom了，则会进行回收
  - 弱：只要发生GC，就会被回收
  - 虚：回收时收到通知，不能通过虚引用获得对象

- GC的历史发展
  - JDK1.4：2002 Parallel GC 和Concurrent Mark Sweep GC
  - JDK1.6：Parallel GC在1.6之后变成hotspot的默认GC
  - JDK1.7：2012年 G1可用
  - JDK9：2017年G1为默认GC
  - JDK10：2018中G1通过并行来改善最坏情况下的延迟
  - JDK11: 2018年 引入Epsilon垃圾回收器。也同时引入ZGC，可伸缩低延迟垃圾回收器。
  - JDK12：2019年发布，增强G1，自动返回未用堆内存给操作系统。同时引入shenandoah gc。
  - JDK13：2019年9月发布，增强ZGC，自动返回未用堆内存给操作系统。
  - JDK14：2020年3月发布，CMS回收器删除，扩展ZGC在mac和win上的使用。

- 垃圾回收器简介

  - Serial+Serial Old：串行的收集器，client的默认
  - ParNew:是并行的回收算法,对应Serial的并行版。可以配合Serial Old的或者CMS处理老年代
    - 不是性能永远比线程的好，多核环境下 需要设置合适的线程数。单核情况下serial更好一点
    - -XX:ParallelGCThreads可以去配置线程数
    - 
  - Parallel+ParallelOld：也是并行的。性能和ParNew差不多，但是区别是吞吐量优先，而且是不同的GC框架。
    - 自适应调节策略。
    - 适合后台运行比较多，交互少。如批量处理，Job，工资计算，科学计算等等
  - CMS
  - G1

  

- 小结：

  - 如果想最小化使用内存和并发开销，选用Serial GC
  - 如果想最大化应用吞吐量，则使用ParallelGC
  - 如果想最小停顿，则使用CMS GC

